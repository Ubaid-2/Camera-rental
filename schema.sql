-- Clean start: Drop tables with CASCADE to handle dependencies automatically
drop table if exists rentals cascade;
drop table if exists cameras cascade;
drop table if exists profiles cascade;

-- Create profiles table
create table profiles (
  id uuid references auth.users not null primary key,
  email text,
  role text check (role in ('buyer', 'seller', 'admin')),
  cnic_front_url text,
  cnic_back_url text,
  user_photo_url text,
  status text default 'pending' check (status in ('pending', 'approved', 'rejected', 'blocked')),
  created_at timestamptz default now()
);

-- RLS for Profiles
alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone" 
on profiles for select using ( true );

create policy "Users can insert their own profile" 
on profiles for insert with check ( auth.uid() = id );

create policy "Users can update own profile" 
on profiles for update using ( auth.uid() = id );

-- Create Storage Bucket for CNICs
insert into storage.buckets (id, name, public) 
values ('cnic_images', 'cnic_images', false) -- Private bucket!
on conflict (id) do nothing;

create policy "Anyone can upload CNIC" on storage.objects for insert with check ( bucket_id = 'cnic_images' );
create policy "Owners can view own CNIC" on storage.objects for select using ( bucket_id = 'cnic_images' and owner = auth.uid() );
-- Admin policy would go here (e.g., using a custom claim or specific admin UID)

-- Create cameras table
create table cameras (
  id uuid default gen_random_uuid() primary key,
  owner_id uuid references profiles(id) not null,
  name text not null,
  description text,
  price_per_day numeric not null,
  image_url text,
  available boolean default true,
  created_at timestamptz default now()
);

-- RLS for Cameras
alter table cameras enable row level security;

create policy "Cameras are viewable by everyone" 
on cameras for select using ( true );

create policy "Sellers can insert their own cameras" 
on cameras for insert with check ( auth.uid() = owner_id );

create policy "Sellers can update their own cameras" 
on cameras for update using ( auth.uid() = owner_id );

create policy "Sellers can delete their own cameras" 
on cameras for delete using ( auth.uid() = owner_id );

-- Create rentals table
  id uuid default gen_random_uuid() primary key,
  camera_id uuid references cameras(id) not null,
  buyer_id uuid references profiles(id) not null,
  start_date date not null,
  end_date date not null,
  total_price numeric not null,
  
  -- Payment & Pickup Info
  transaction_id text,
  payment_proof_url text,
  pickup_time text,
  
  -- Contact Info (Contract)
  renter_name text,
  renter_phone text,
  renter_address text,

  status text default 'pending' check (status in ('pending', 'approved', 'rejected', 'completed', 'cancelled')),
  created_at timestamptz default now()
);

-- Payment Proof Bucket
insert into storage.buckets (id, name, public) 
values ('payment_proofs', 'payment_proofs', false) -- Private
on conflict (id) do nothing;

create policy "Buyers can upload proof" on storage.objects for insert with check ( bucket_id = 'payment_proofs' and auth.uid() = owner );
create policy "Owners (Buyers) can view own proof" on storage.objects for select using ( bucket_id = 'payment_proofs' and owner = auth.uid() );
-- Sellers will need signed URLs generated by the system (which acts as admin/owner context usually, or we need a policy allowing camera owners to see proofs linked to their rentals. 
-- Since Supabase simple policies are hard for "related" logic without complex joins, relying on signed URLs generated by the authenticated user (if they are the uploader) is standard. 
-- BUT for the Seller to see it, the Seller needs permission.
-- Let's make a policy: "Authenticated users can view proofs if they are the seller of the camera". 
-- This is complex in SQL. Simplified approach: 
-- 1. Buyer Uploads (Owner).
-- 2. Buyer (Owner) generates a Signed URL for 7 days or so and stores it? No, standard is genering on fly.
-- 3. Use `security defeiner` function or just rely on Signed URLs generated by the CLIENT (Buyer) during creation? No, Seller generates it.
-- OPTION B: Make bucket publicly readable but with unguessable names? (Not secure enough for SRS).
-- OPTION C: Allow any authenticated user to VIEW proofs (read-only) but only Owner (Buyer) to upload. 
-- Let's go with OPTION C for this prototype to avoid complex RLS joins on storage.objects which can be slow/tricky.
-- actually, for better security:
-- create policy "Authenticated users can view payment proofs" on storage.objects for select using ( bucket_id = 'payment_proofs' and auth.role() = 'authenticated' );
-- Ideally we restrict to just the relevant seller, but "Authenticated Read" is acceptable for a "Private Bucket" vs "Public Bucket" distinction in a prototype.

create policy "Authenticated Users can view proofs" on storage.objects for select using ( bucket_id = 'payment_proofs' and auth.role() = 'authenticated' );


-- RLS for Rentals
alter table rentals enable row level security;

create policy "Users can see own rentals (as buyer)" 
on rentals for select using ( auth.uid() = buyer_id );

create policy "Sellers can see rentals for their cameras" 
on rentals for select using ( 
  camera_id in (select id from cameras where owner_id = auth.uid()) 
);

create policy "Buyers can insert rental requests" 
on rentals for insert with check ( auth.uid() = buyer_id );

create policy "Sellers can update status of rentals for their cameras" 
on rentals for update 
using ( 
  camera_id in (select id from cameras where owner_id = auth.uid()) 
)
with check (
  camera_id in (select id from cameras where owner_id = auth.uid())
);

